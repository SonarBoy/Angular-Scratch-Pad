<div class="jumbotron jumbotron-fluid">
    <div class="container">
        <h1 class="display-4">ALL THE ANGULAR EXAMPLES IN ONE PLACE.</h1>
        <h1 class="display-4">TEMPLATE SYNTAX.</h1>
        <p class="lead">These are the angular examples that you need to understand.</p>
    </div>
</div>


<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Interpolation</strong></h1>
    <p>-refers to embedding expressions into marked up text.</p>
    <p>-by default, interpolation uses as its delimiter the double curly braces.</p>
    <p>-The Value: {{interpolatedValue}}</p>

    <br>
    <br>
    <br>

    <p> More generally, the text between the braces is a template expression
        that Angular first evaluates and then converts to a string. The following
        interpolation illustrates the point by adding two numbers:

        <br>
        <br>

        <strong>The sum of 1 + 1 is {{1 + 1}}.</strong>
    </p>

    <p>
        The expression can invoke methods of the host component such as getVal()
        in the following example:

        <br>
        <br>

        <strong>The sum of 1 + 1 is not {{1 + 1 + getVal()}}</strong>
    </p>

    <p>
        - Angular evaluates all expressions in double curly braces, converts the expression
        results to strings, and links them with neighboring literal strings. Finally, it assigns
        the composite interpolated result to an element or directive property.
    </p>

    <div style=" border: 2px solid ">
        <img src="{{backgroundImage}}">


        <p></p>
    </div>

    <h1>Template expressions.</h1>



    <p>A template expression produces a value and appears within the double curly braces,.
        Angular executes the expression and assigns it to a property of a binding target; the target
        could be an HTML element, a componenet, or a directive.

        In the property binding, a template expression appears in quotes to the right of the = symbol
        as in [property] ="expression"
    </p>

    <p>
        You can't use JavaScript expressions that have or promote side effects, including:
    </p>
    <ul>
        <li>Assingments =,+=,-=,... </li>
        <li>Operators suchs as new typeof instanceof etc.</li>
        <li>Chaining expressions with ; or,</li>
        <li>The increment and decrement operators ++ and --</li>
        <li>Some of the ES2015+ operators</li>
    </ul>


    <h1>Expression context</h1>

    <p>The expression context is typically the componenet instance. In the following
        snippets, the recomended variable is within double curly braces and the image location is within the item ImageUrl2
    </p>

    <h4>{{recommended}}</h4>
    <img [src]="itemImageUrl2">


    <h4>Simplicity</h4>
    <p>Altho its possible to write comple template expressions, its better to avoid it

        A property name or method call should be the norm, but an occasional Boolean negation, !, is
        OK. Otherwise confine application and business logic to the component, whereitis easier to develop and test.
    </p>

    <h4>No visible side effects</h4>
    <p>A template expression should not change any application state other than the value of the target
        property.

        This rule is essential to Angular's "unidirectional data flow" policy. You should never worry that reading
        a component value might change some other displayed value. The view should be stable throughout a single
        rendering pass.
    </p>



</div>

<br>
<br>
<br>

<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Template Statements</strong></h1>

    <p>- A template statement responds to an event raised by a binding target such as
        an element, component, or directive.</p>
    <br>

    <button (click)="breakOut()">Tester</button>

    <p>Responding to events is the other side of Angular's "unidirectional data flow".
        You're free to change anything, anywhere, during this turn of the event loop.
    </p>
    <br>



    <h4>Statement Context</h4>
    <br>

    <p>- As with expressions, statements can refer only to what's in the statment
        context such as an event handling method of the component instance.
    </p>
    <br>

    <p>- The statement context amy also refer to properties of the template's own
        context. In the following examples, the template $event object, a template input variable
        (let hero), and a template reference variable (#heroForm) are passed to an event handling
        method of the component. <br>

        <br>
        <!--
        button (click)="onSave($event)">Save /button> <br>
        button *ngFor="let hero of heroes" (click)="deleteHero(hero)">{{hero.name}} /button> <br>
        form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... /form> <br>
            -->
        <br>
        -Template context names take precedence over component context names. In deleteHero(hero)
        above, the hero is the template input variable, not the component's hero property.
    </p>

    <div>
    </div>
</div>


<br>
<br>
<br>

<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Binding Syntax</strong></h1>

    <p>-Data-Binding is a mechanism for coordinating what users see, specifically
        with application data values. While you could push values to and pull values
        from HTML, the application is easier to write, read and maintain if you turn These
        tasks over to a binding framework. You simply declare bindings between binding
        sources, target HTML elements, and let the framework do the rest.


    </p>

    <table class="table table-dark">
        <tr>
            <td>Type</td>
            <td>Syntax</td>
            <td>Category</td>
        </tr>
        <tr>
            <td>Interpolation <br>
                Property <br>
                Attribute <br>
                Class <br>
                Style <br>
            </td>
            <td> CB expression CB <br>
                [target]="expression" <br>
                bind-target="expression"
            </td>
            <td>One-way <br>
                from data <br>
                source to view</td>
        </tr>
        <tr>
            <td>Event</td>
            <td>(target)="statement" <br>
                on-target="statement"</td>
            <td>One-way <br>
                from view target <br>
                to data source.</td>
        </tr>
        <tr>
            <td>Two-way</td>
            <td>[(target)]="expression" <br>
                bindon-target="expression"</td>
            <td>Two-way</td>
        </tr>
    </table>

    <p>
        Binding types other than interpolation have a target name to the left of
        the equal sign, either surrounded by punctuation, [] or (), or preceded by a
        prefix: bind-, on-, bindon-,<br>

        <strong>The target of a binding is the property or event inside the binding <br>
            punctuation: [],() or [()] </strong>
    </p>
    <br>
    <br>

    <h4>Data-binding and HTML</h4>
    <p>
        - With data-binding, you can control things like the state of a button:
        button [disabled]="isUnchanged" Save /button <br>

        <br>
        <br>

        -Notice that the binding is to the disabled property of the button's DOM element, <br>
        not the attribute. This applies to data-binding in general. Data-binding works with <br>
        properties of DOM elements, componenets and directives, not HTML attributes.<br>
    </p>

    <br>
    <br>

    <h3>HTML attribute vs. DOM property.</h3>
    <p>- The distinction between an HTML attribute and a DOM property is key to understanding <br>
        how Angular binding works. <br>

        <strong>- Attributes are defined by HTML. Properties are accessed from DOM nodes.</strong> <br>
        <strong>- Properties are accessed from DOM (Document Object Model) nodes. </strong>

    </p>

    <ul>
        <li>A few HTML attributes have 1:1 mapping to properties; for example, id.</li>
        <li>Some HTML attributes dont have corresponding properties; for example, aria-*.</li>
        <li>Some DOM properties don't have corresponding attributes; for example, textContent.</li>
    </ul>

    <strong>
        <h3>Template binding works with properties and events not attributes.</h3>
    </strong>


    <h2>Example 1: an input></h2>

    <p>When the browser renders <input #htmlExample type="text" value="Sarah"> <br>
        It creates a corresponding DOM node with a value property initialized to "Sarah"
    </p>

    <strong>The HTML attribute value specifies the initial value; the DOM value property is the current
        value.</strong>
    <br>
    <br>

    <button (click)="getHTMLAttributeValue()">Attribute</button><br>
    <button (click)="getDOMPropertyValue()">DOM Property</button><br>
    <br>
    <p>When the user enters "Sally" into the input, the DOM value becomes "Sally"</p>

    <br>
    <br>

    <h2>Example 2: a disabled button</h2>

    <p>The disabled attribute is another example. A button's disabled property is
        false by default so the button is enabled.
    </p>

    <br>

    <p>When you add the disabled attribute, its presence alone initializes the button's
        disabled property to true so the button is disabled.
    </p>

    <br>

    <p>Adding and removing the disabled attribute disables and enables the button.
        However, the value of the attribute is irrelevant, which is why you cannot enable a
        button by writing button disabled = "false" Still disabled /button
    </p>


    <strong>
        The target of a data-binding is something in the DOM. Depending on the binding
        type, the target can be a property (element, component, or directive), an event
        (element, component, or directive), or sometimes an attribute name. The following
        table summarizes the targets for the different binding types.
    </strong>

    <br>
    <br>
    <br>

    <table class="table table-dark">
        <tr>
            <th>TYPE</th>
            <th>TARGET</th>
            <th>EXAMPLES</th>
        </tr>

        <tr>
            <td>Property</td>
            <td>Element property <br>
                Componenet property <br>
                Directive property</td>
            <td>src, hero and ngClass in the following: <br>
                <img src="assets/PropertyBinding.png">
            </td>
        </tr>

        <tr>
            <td>Event</td>
            <td>Element event <br>
                Component event<br>
                Directive event</td>
            <td>click deleteRequest, and myClick in the following: <br>
                <img src="assets/EventBinding.png"></td>
        </tr>

        <tr>
            <td>Two-way</td>
            <td>Event and property</td>
            <td><img src="assets/Two-Way.png"></td>
        </tr>

        <tr>
            <td>Attribute</td>
            <td>Attrubute (the exception)</td>
            <td><img src="assets/AttributeBinding.png"></td>
        </tr>

        <tr>
            <td>Class</td>
            <td>class property</td>
            <td><img src="assets/ClassBinding.png"></td>
        </tr>

        <tr>
            <td>Style</td>
            <td>style property</td>
            <td><img src="assets/StyleBinding.png"></td>
        </tr>

    </table>

</div>

<br>
<br>

<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Property Binding</strong></h1>
    <p>Use property binding to set properties of target elements or directive <br>
    @Input() decorators.</p>
    
    <h3>One-way In</h3>
    <p>Property binding flows a value in one direction, from a component's property to a target element <br>
    component ---> target element
    </p>

    <p class="alert alert-danger">
        You can't use property binding to read or pull values out of target elements. Similarly,
        you cannot use property binding to call a method on the target elements. If the element 
        raises events you can listen to them with an event binding.
    </p>

    <img [src]="itemImage">

    <p>Here is an example of the colum span with the colums as a property binding</p>

    <table class="table table-dark">
        <tr>
            <td [colSpan]="randomColumnValue"n class="table-light">Span 2 columns</td>
            <td>Test</td>
            <td>Test</td>
        </tr>
    </table>
    <p>Here we have a disabled button with the disabled property bound:</p>
    <button [disabled]="isUnchanged">Disabled Button</button>


    <br>
    
    <p [ngClass]="classes">Element properties may be the more common targets, but Angular looks first <br>
    to see if the name is a property of a known directive, as it is in the following example (This paragraph 
    is green because of the special classes added).
    </p>

    <p>Technically, Angular is matching the name to a directive @Input(), one of the property names is listed in <br>
       names listed in the directive's inputs array or a property decorated with @Input(). Such inputs map to 
       the directive's own properties.
    </p>

    <h3>Avoid Side effects.</h3>

    <br>

    <p>Evaluation of a template expression should have no visible side effects. You can't assign a value to anything in a  <br>
    property binding expression nor use the increment and decrement operators.
    </p>

    
    <br>

    <h3>Return the proper type</h3>

    <p>The template expression should evaluate to the type of value that the target property expects. Return <br>
        a string if the target property expects a string, a number if it expects a number an object if it expects an object <br>
        and so on. 
    </p>


    <h1>Passing Strings </h1>
    <p>Here we are passong the value "itemList" defined in our angular-examples.ts . It gets digested by the item-details component 
        by passing it to the input value of "items" in the item-details.ts file.
    </p>

    <app-item-detail [firstItem]="names" [secondItem]="maker" [thirdItem]="qty" [items]="itemList" ></app-item-detail>

    <br>

    <h1>Remember the brackets</h1>

    <p>The brackets tell Angular to evaluate the template expression. If you omit the brackets, Angular treats the string as a <br>
        constant and initializes the target property with that string. 
    </p>

    <br>

    <h1>One-Time string initialization.</h1>

    <p>You should omit the brackets when all of the following are true:</p>
    <ol>
        <li><h1>The target property accepts a sting value.</h1></li>
        <li><h1>The string is a fixed value that you can put directly into the template</h1></li>
        <li><h1>This initial value never changes.</h1></li>
    </ol>

    <br>

    <h1>Content Security</h1>

    <p>Imagnine the following malicious content. <br>
    
    {{evilTitle}}
    </p>

    <br>

    <p>In the above case, the HTML displays as is, and the Javascript does not execute. Angular does not allow HTML <br>
    with script tags to leak into the browser neither with interpolcation nor property binding.
    </p>

</div>
<br>

<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Attribute, class and style Bindings</strong></h1>
    <br>
    <br>

    <h1>Attribute Binding</h1>

    <p>Set the value of an attribute directly with an attribute binding. This is the only exception to the rule that 
        a binding sets a target property and the only binding that creates and sets an attribute.
    </p>

    <br>

    <p>Attribute binding syntax resembles property binding but instead of an element property between brackets, starts
        with the prefix attr, followed by a dot (.), and the name of the attribute. You then set the attribute value, using
        an expression that resolves to a string, or remove the attribute when the expression resolves to null

        <br>
        Following button is an example
    </p>

    <button [attr.aria-label]="actionName">{{actionName}} with Aria</button>

    <h1>Class Binding</h1>

    <p>Here is how to set a class binding without a binding in plain HTML.
    <br>
    To create a single class binding start with the prefix class followed by a dot (.) and the name of the CSS class
    (for example, class.foo =  "hasFoo"). Angular adds the class when the bound expression is truthy and removes the 
    class when the expression is falsy

    
    </p>
    <h1 [class.foo]="hasFoo">This is a test</h1>
    <h1 [class]="fooClass">This is another test</h1>
    
    <img src="assets/ClassBindingChart.png">

    <br>
    <br>
    <br>

    <h1>Style Bindings</h1>

    <p>Here's how to set the style arrtibute without a binding in plain HTML: </p>
    <div style="color: blue">Some text</div>

    <p>You can also set styles dynamically with a style binding.</p>

    <br>

    <p>To create a single style binding, start with the prefix style followed by a dot(.)<br>
    and the name of the CSS style property (for example style.width= "width"). The property will 
    be set to the value of the bound expression, which is normally a string. Optionally, you can add 
    a unit extension like em or % which requires a number. 
    </p>

    <div [style.color]="color" [style.border]="border">THIS IS A TEST FOR THE STYLE BINDING</div>
    
    <br>

    <img src="assets/StyleBindingChart.png">

    <br>

    <p>If there are multiple styles youd like to toggle you can bind to the [style] property directly
        without the dot (for example, style="styleExpr"). The expression attached to the style binding 
        is most often a string list of styles like "width: 100px;"
    </p>

    <br>
    <br>

    <h1>Styling Precedence</h1>

    <img src="assets/StylingPrecedence.png">
    <br>

    <h2>The more specific a class or style binding is, the higher its precedence.</h2>

    <p>A binding to a specific class (for example, [class.foo]) will take precedence over a generic class 
        binding, and a binding to a specific style (for example, style.bar) will take precedence over a 
        generic style binding. 
    </p>

    <div [class.special]="isSpecial" [class]="classExpr">Some Text</div>
    
    <p>In addition, bindings take precedence over static attributes.
       In the following case, class and class with square brackets have similar specificty, but the
       class with square brackets binding will take precedence because its dynamic.
    </p>

    <div class="notSpecialClassExample" [class]="isSpecial">This is another test</div>

    <div style="background-color: blue" [style]="styleExpr">Some text.</div>


</div>

<br>

<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Event Binding</strong></h1>
    <br>

    <p>Event binding allows you to listen for certain events such as keystrokes, mouse movements
        clicks and touches. <br>

        Angular event binding syntax consists of a target event name within parentheses on the left of 
        an equal sign and a quoted template statement on the right. The following event binding listens for <br>
        button's click events, calling the component's onSave() method whenever a click occurs.
    </p>

    <button (click)="onSave($event)">Save</button>

    <br>

    <p>Element events may be the more common targets but Angular looks first to see if the name matches <br>
    an event property of a known directive, as it does in the following example</p>

    <br>

    <p>myClick is an event on the custom Click Directive:</p>
    <button (myClick)="clickMessage=$event" clickable>Click with my button</button>
    {{clickMessage}}

    <button (myClick)="clickMessage=$event" clickable>click with myClick</button>
    {{clickMessage}}

    <p>Note Here the click.directives.ts must also be added to the declarations in the app.module.ts</p>

    <br>

    <h1>$event and event handling statements.</h1>

    <p>In an event binding, Angular sets up an event handler for the target event. <br>
        When the event is raised the handler executes the template statement. The template statement
        typically involves a reciever which performs an action in response to the event such as 
        storing a value from the html control into a model. <br>

        The binding conveys information about the event. This information can include data values such as <br>
        an event object, string or number named $event.

    </p>

    <input [value]="currentItem.name" (input)="currentItem.name=$event.target.value"><br>
    <h3>{{currentItem.name}}</h3>

    <p>This code sets the input value property by binding to the name property. To listen for changes to the <br>
    value, the code binds to the input event of the input element. When the user makes changes, the input event is <br>
    and the binding executes the statement within a context that includes the DOM event object $event.</p>

    <br>

    <h1>Custom events with EventEmitter</h1>

    <p>Directives typically raise custom events with an Angular Event Emitter. The directives creates an EventEmitter and exposes <br>
    it as a property. The directive calls EventEmitter.emit(payload) to fire an event, passing in a message payload, which can be anything<br>
    Parent directives listen for the event by binding to this property and accessing the payload through the $event object
    </p>

    <br>

    <app-item-detail [firstItem]="names" [secondItem]="maker" [thirdItem]="qty" [items]="itemList" [tester]="currentItem.name" ></app-item-detail>

    <br>

    <p>Consider an ItemDetailComponent that presents item information and responds to user actions. Although the ItemDetailComponent<br>
    has a delete button, it doesn't know how to delete the hero. It can only raise an event reporting the user's delete request.</p>


</div>

<br>

<div class="container section">
    <h1 class="jumbotron jumbotron-fluid"><strong>Event Binding</strong></h1>
    <br>


    <h1>Contents</h1>

    <ul>
        <li>Basic of Two-way binding</li>
        <li>Two-way binding in forms</li>
    </ul>

    <p>Two-way binding gives your app a way to share data between a component class and its template <br>
    
    Angular offers a special two-way data binding syntax for this purpose. The banana box syntax combines the brackets of
    property binding with the parentheses of event binding.

    </p>

    <ul>
        <li>Sets a specific element property.</li>
        <li>Listens for an element change event.</li>
    </ul>

    <br>

    <p>The syntax is easy to demonstrate when the element has a settable property called x and a corresponding event named
        xChange. Here's a SizerComponent that fits this pattern. It has a size value property and a companion sizeChange event.
    </p>
    
    
    <app-item-detail [size]="fontSizePx" ></app-item-detail>
    <label>FontSize (px): <input [(ngModel)]="fontSizePx"></label>
    <label>Input: <input [(ngModel)]="firstItem"></label>

    <br>

    <p>The initial size is an input value from a property binding. Clicking the buttons increases or decreases the size, within 
        min/max value constraints and then raises or emits the sizeChange event with the adjusted size. 
    </p>

    <br>
    
    <app-item-detail [(size)]="fontSizePx" ></app-item-detail>

</div>