<div class="jumbotron jumbotron-fluid">
    <div class="container">
      <h1 class="display-4">ALL THE ANGULAR EXAMPLES IN ONE PLACE.</h1>
      <h1 class="display-4">TEMPLATE SYNTAX.</h1>
      <p class="lead">These are the angular examples that you need to understand.</p>
    </div>
  </div>


  <div class="container" style="border: 1px solid black;">
    <h1 class="jumbotron jumbotron-fluid" ><strong>Interpolation</strong></h1>
    <p>-refers to embedding expressions into marked up text.</p>
    <p>-by default, interpolation uses as its delimiter the double curly braces.</p>
    <p>-The Value: {{interpolatedValue}}</p>

    <br>
    <br>
    <br>

    <p> More generally, the text between the braces is a template expression
        that Angular first evaluates and then converts to a string. The following
        interpolation illustrates the point by adding two numbers:

        <br>
        <br>

        <strong>The sum of 1 + 1 is {{1 + 1}}.</strong>
    </p>

    <p>
        The expression can invoke methods of the host component such as getVal()
        in the following example: 

        <br>
        <br>

        <strong>The sum of 1 + 1 is not {{1 + 1 + getVal()}}</strong>
    </p>

    <p>
        - Angular evaluates all expressions in double curly braces, converts the expression
        results to strings, and links them with neighboring literal strings. Finally, it assigns
        the composite interpolated result to an element or directive property.
    </p>

    <div style=" border: 2px solid ">
        <img src="{{backgroundImage}}">


        <p></p>
    </div>

    <h1>Template expressions.</h1>



    <p>A template expression produces a value and appears within the double curly braces,.
       Angular executes the expression and assigns it to a property of a binding target; the target
       could be an HTML element, a componenet, or a directive. 

       In the property binding, a template expression appears in quotes to the right of the = symbol
       as in [property] ="expression" 
    </p>

    <p>
        You can't use JavaScript expressions that have or promote side effects, including:
    </p>
        <ul>
            <li>Assingments =,+=,-=,... </li>
            <li>Operators suchs as new typeof instanceof etc.</li>
            <li>Chaining expressions with ; or,</li>
            <li>The increment and decrement operators ++ and --</li>
            <li>Some of the ES2015+ operators</li>
        </ul>
    

    <h1>Expression context</h1>

    <p>The expression context is typically the componenet instance. In the following 
        snippets, the recomended within double curly braces and the 
    </p>        

        <h4>{{recommended}}</h4>
        <img [src]="itemImageUrl2">
    

    <h4>Simplicity</h4>
    <p>Altho its possible to write comple template expressions, its better to avoid it

        A property name or method call should be the norm, but an occasional Boolean negation, !, is 
        OK. Otherwise confine applicaton and business logic to the component, whereitis easier to develop and test.
    </p>

    <h4>No visible side effects</h4>
    <p>A template expression should not change any application state other than the value of the target
        property.

        This rule is essential to Angular's "unidirectional data flow" policy. You should never worry that reading 
        a component value might change some other displayed value. The view should be stable throughout a single
        rendering pass. 
    </p>



  </div>

  <br>
  <br>
  <br>

  <div class="container" style="border: 1px solid black;">
    <h1 class="jumbotron jumbotron-fluid" ><strong>Template Statements</strong></h1>

    <p>- A template statement responds to an event raised by a binding target such as 
    an element, component, or directive.</p>
    <br>

    <button (click)="breakOut()">Tester</button>

    <p>Responding to events is the other side of Angular's "unidirectional data flow".
    You're free to change anything, anywhere, during this turn of the event loop.
    </p>
    <br>



    <h4>Statement Context</h4>
    <br>

    <p>- As with expressions, statements can refer only to what's in the statment 
    context such as an event handling method of the component instance. 
    </p>
    <br>

    <p>- The statement context amy also refer to properties of the template's own 
    context. In the following examples, the template $event object, a template input variable
    (let hero), and a template reference variable (#heroForm) are passed to an event handling
    method of the component. <br>

    <br>
    button (click)="onSave($event)">Save /button> <br>
    button *ngFor="let hero of heroes" (click)="deleteHero(hero)">{{hero.name}} /button> <br>
    form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... /form> <br>

    <br>
    -Template context names take precedence over component context names. In deleteHero(hero)
    above, the hero is the template input variable, not the component's hero property.
    </p>

  <div>

  <br>
  <br>
  <br>

  <div class="container" style="border: 1px solid black;">
    <h1 class="jumbotron jumbotron-fluid" ><strong>Binding Syntax</strong></h1>

    <p>-Data-Binding is a mechanism for coordinating what users see, specifically
        with application data values. While you could push values to and pull values
        from HTML, the application is easier to write, read and maintain if you turn These
        tasks over to a binding framework. You simply declare bindings between binding 
        sources, target HTML elements, and let the framework do the rest. 

     
    </p>

    <table>
        <tr>
            <td>Type</td>
            <td>Syntax</td>
            <td>Category</td>
        </tr>
        <tr>
            <td>Interpolation <br>
                Property <br>
                Attribute <br>
                Class <br>
                Style <br>
            </td>
            <td> CB expression CB <br>
                [target]="expression" <br>
                bind-target="expression"
            </td>
            <td>One-way <br>
            from data <br>
            source to view</td>
        </tr>
        <tr>
            <td>Event</td>
            <td>(target)="statement" <br>
            on-target="statement"</td>
            <td>One-way <br>
            from view target <br>
            to data source.</td>
        </tr>
        <tr>
            <td>Two-way</td>
            <td>[(target)]="expression" <br>
            bindon-target="expression"</td>
            <td>Two-way</td>
        </tr>
    </table>

    <p>
        Binding types other than interpolation have a target name to the left of
        the equal sign, either surrounded by punctuation, [] or (), or preceded by a 
        prefix: bind-, on-, bindon-,<br>

        <strong>The target of a binding is the property or event inside the binding <br>
            punctuation: [],() or [()] </strong>
    </p>
    <br>
    <br>

    <h4>Data-binding and HTML</h4>
    <p>
        - With data-binding, you can control things like the state of a button:
        button [disabled]="isUnchanged" Save /button <br>

        <br>
        <br>
        
        -Notice that the binding is to the disabled property of the button's DOM element, <br>
        not the attribute. This applies to data-binding in general. Data-binding works with <br>
        properties of DOM elements, componenets and directives, not HTML attributes.<br>
    </p>

    <br>
    <br>

    <h3>HTML attribute vs. DOM property.</h3>
    <p>- The distinction between an HTML attribute and a DOM property is key to understanding <br>
        how Angular binding works. <br>

        <strong>- Attributes are defined by HTML. Properties are accessed from DOM nodes.</strong>

    
    </p>

    <ul>
        <li>A few HTML attributes have 1:1 mapping to properties; for example, id.</li>
        <li>Some HTML attributes dont have corresponding properties; for example, aria-*.</li>
        <li>Some DOM properties don't have corresponding attributes; for example, textContent.</li>
    </ul>

  </div>